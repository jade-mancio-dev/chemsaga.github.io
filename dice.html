<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pro 3D Dice Roll (Centered Arena + Full Pips, Fixed Rotations)</title>
<style>
  :root{
    --arena-size: 6.0; /* meters */
  }
  body {
    margin: 0;
    background: #111;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
    color: white;
    font-family: Arial, sans-serif;
  }
  canvas { display: block; }
  button {
    position: fixed;
    bottom: 24px;
    padding: 10px 20px;
    background: #ff6200;
    border: none;
    color: white;
    font-size: 16px;
    cursor: pointer;
    border-radius: 6px;
    transition: background 0.2s;
  }
  button:hover { background: #e55a00; }
  button:disabled { background: #666; cursor: not-allowed; }
</style>
</head>
<body>
<canvas id="diceCanvas"></canvas>
<button id="rollBtn">Roll Dice</button>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.19.0/dist/cannon-es.js';

/* -----------------------------
   Scene & Renderer
------------------------------ */
const scene = new THREE.Scene();
scene.background = new THREE.Color('#222');

const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(0, 6.5, 9.5);
camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('diceCanvas'), antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;

/* -----------------------------
   Lights
------------------------------ */
scene.add(new THREE.AmbientLight(0xffffff, 0.55));
const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
dirLight.position.set(6, 12, 6);
dirLight.castShadow = true;
dirLight.shadow.mapSize.set(1024, 1024);
scene.add(dirLight);

/* -----------------------------
   Physics World
------------------------------ */
const world = new CANNON.World();
world.gravity.set(0, -9.82, 0);
world.broadphase = new CANNON.NaiveBroadphase();

const matFloor = new CANNON.Material('floor');
const matDice  = new CANNON.Material('dice');
world.addContactMaterial(new CANNON.ContactMaterial(matFloor, matDice, {
  restitution: 0.15,
  friction: 0.6
}));

/* -----------------------------
   Floor
------------------------------ */
const ARENA_SIZE = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--arena-size')) || 6.0;

const floorBody = new CANNON.Body({ mass: 0, shape: new CANNON.Plane(), material: matFloor });
floorBody.quaternion.setFromEuler(-Math.PI/2, 0, 0);
world.addBody(floorBody);

const floor = new THREE.Mesh(
  new THREE.PlaneGeometry(ARENA_SIZE, ARENA_SIZE),
  new THREE.MeshStandardMaterial({ color: 0x333333 })
);
floor.rotation.x = -Math.PI/2;
floor.receiveShadow = true;
scene.add(floor);

/* -----------------------------
   Arena Walls (invisible physics)
------------------------------ */
const wallHeight = 1.0;
const wallThickness = 0.25;
function addWall(x, y, z, halfExtents, ry=0){
  const body = new CANNON.Body({ mass: 0 });
  body.addShape(new CANNON.Box(new CANNON.Vec3(...halfExtents)));
  body.position.set(x, y, z);
  body.quaternion.setFromEuler(0, ry, 0);
  world.addBody(body);
}
const half = ARENA_SIZE/2;
addWall( half + wallThickness, wallHeight/2, 0, [wallThickness, wallHeight/2, half]);
addWall(-half - wallThickness, wallHeight/2, 0, [wallThickness, wallHeight/2, half]);
addWall(0, wallHeight/2,  half + wallThickness, [half, wallHeight/2, wallThickness]);
addWall(0, wallHeight/2, -half - wallThickness, [half, wallHeight/2, wallThickness]);

// low visual rim (optional)
const rimMat = new THREE.MeshBasicMaterial({ color: 0x222222 });
function rim(w,h,d,px,py,pz,ry=0){
  const m = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), rimMat);
  m.position.set(px,py,pz); m.rotation.y = ry; scene.add(m);
}
const rimH=0.2, rimT=0.05;
rim(ARENA_SIZE+rimT*2, rimH, rimT, 0, rimH/2,  half+rimT/2);
rim(ARENA_SIZE+rimT*2, rimH, rimT, 0, rimH/2, -half-rimT/2);
rim(rimT, rimH, ARENA_SIZE+rimT*2,  half+rimT/2, rimH/2, 0);
rim(rimT, rimH, ARENA_SIZE+rimT*2, -half-rimT/2, rimH/2, 0);

/* -----------------------------
   Dice Geometry (rounded box)
------------------------------ */
function createRoundedBox(w,h,d,r,smooth){
  const shape = new THREE.Shape();
  const eps = 0.0001, rr = r - eps;
  shape.absarc(eps, eps, rr, -Math.PI/2, -Math.PI, true);
  shape.absarc(eps, h - r*2, rr, Math.PI, Math.PI/2, true);
  shape.absarc(w - r*2, h - r*2, rr, Math.PI/2, 0, true);
  shape.absarc(w - r*2, eps, rr, 0, -Math.PI/2, true);
  const g = new THREE.ExtrudeGeometry(shape, {
    depth: d - r*2, bevelEnabled: true, bevelSegments: smooth,
    steps: 1, bevelSize: rr, bevelThickness: rr
  });
  g.center();
  return g;
}

const diceSize = 1.5;
const diceGeom = createRoundedBox(diceSize, diceSize, diceSize, 0.2, 12);
const diceMat  = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.2, roughness: 0.35 });
const diceMesh = new THREE.Mesh(diceGeom, diceMat);
diceMesh.castShadow = true;
scene.add(diceMesh);

/* -----------------------------
   Pips (cylinders) — FIXED ROTATIONS
------------------------------ */
function addDot(position, rotation){
  // Slightly thicker, and push a bit further out to avoid bevel z-fight
  const dotGeom = new THREE.CylinderGeometry(0.12, 0.12, 0.08, 32);
  const dotMat  = new THREE.MeshStandardMaterial({ color: 0x000000 });
  const dot = new THREE.Mesh(dotGeom, dotMat);
  dot.castShadow = true;

  // Push outward along the face normal
  const outward = position.clone().normalize().multiplyScalar(0.035);
  dot.position.copy(position.clone().add(outward));

  dot.rotation.set(...rotation);
  diceMesh.add(dot);
}

const s = diceSize / 2;

// Face 1 (+Z): axis needs to align to Z → rotate around X by +90°
addDot(new THREE.Vector3(0, 0, s), [Math.PI/2, 0, 0]);

// Face 2 (−X): axis must align to −X → rotate around Z by +90°
addDot(new THREE.Vector3(-s, -0.3, -0.3), [0, 0,  Math.PI/2]);
addDot(new THREE.Vector3(-s,  0.3,  0.3), [0, 0,  Math.PI/2]);

// Face 3 (+Y): default cylinder axis is +Y → no rotation needed
addDot(new THREE.Vector3(-0.3,  s, -0.3), [0, 0, 0]);
addDot(new THREE.Vector3( 0.0,  s,  0.0), [0, 0, 0]);
addDot(new THREE.Vector3( 0.3,  s,  0.3), [0, 0, 0]);

// Face 4 (+X): axis must align to +X → rotate around Z by −90°
addDot(new THREE.Vector3( s, -0.3, -0.3), [0, 0, -Math.PI/2]);
addDot(new THREE.Vector3( s, -0.3,  0.3), [0, 0, -Math.PI/2]);
addDot(new THREE.Vector3( s,  0.3, -0.3), [0, 0, -Math.PI/2]);
addDot(new THREE.Vector3( s,  0.3,  0.3), [0, 0, -Math.PI/2]);

// Face 5 (−Y): axis should be −Y → rotate 180° around X (or Z); either is fine
addDot(new THREE.Vector3(-0.3, -s, -0.3), [Math.PI, 0, 0]);
addDot(new THREE.Vector3(-0.3, -s,  0.3), [Math.PI, 0, 0]);
addDot(new THREE.Vector3( 0.0, -s,  0.0), [Math.PI, 0, 0]);
addDot(new THREE.Vector3( 0.3, -s, -0.3), [Math.PI, 0, 0]);
addDot(new THREE.Vector3( 0.3, -s,  0.3), [Math.PI, 0, 0]);

// Face 6 (−Z): axis needs to align to −Z → rotate around X by −90°
addDot(new THREE.Vector3(-0.3, -0.3, -s), [-Math.PI/2, 0, 0]);
addDot(new THREE.Vector3(-0.3,  0.0,  -s), [-Math.PI/2, 0, 0]);
addDot(new THREE.Vector3(-0.3,  0.3,  -s), [-Math.PI/2, 0, 0]);
addDot(new THREE.Vector3( 0.3, -0.3,  -s), [-Math.PI/2, 0, 0]);
addDot(new THREE.Vector3( 0.3,  0.0,  -s), [-Math.PI/2, 0, 0]);
addDot(new THREE.Vector3( 0.3,  0.3,  -s), [-Math.PI/2, 0, 0]);

/* -----------------------------
   Dice Physics Body
------------------------------ */
const diceBody = new CANNON.Body({ mass: 1, material: matDice });
diceBody.addShape(new CANNON.Box(new CANNON.Vec3(diceSize/2, diceSize/2, diceSize/2)));
diceBody.position.set(0, 3, 0);
diceBody.linearDamping = 0.35;
diceBody.angularDamping = 0.42;
world.addBody(diceBody);

/* -----------------------------
   Rolling Logic
------------------------------ */
const rollBtn = document.getElementById('rollBtn');
let isRolling = false;

function rollDice(){
  diceBody.position.set(0, 2.5, 0);
  diceBody.quaternion.set(0, 0, 0, 1);
  diceBody.velocity.setZero();
  diceBody.angularVelocity.setZero();

  const lateral = 1.8;
  const up = 9.0;
  const vx = (Math.random()*2 - 1) * lateral;
  const vz = (Math.random()*2 - 1) * lateral;
  diceBody.velocity.set(vx, up, vz);

  const spinMag = 8 + Math.random()*6;
  diceBody.angularVelocity.set(spinMag*0.2, spinMag, spinMag*0.15);
}

rollBtn.addEventListener('click', () => {
  if (isRolling) return;
  isRolling = true;
  rollBtn.disabled = true;
  rollDice();
  setTimeout(() => { isRolling = false; rollBtn.disabled = false; }, 2500);
});

/* -----------------------------
   Loop & Resize
------------------------------ */
function animate(){
  requestAnimationFrame(animate);
  world.step(1/60);

  // safety clamp inside arena
  const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
  const safe = ARENA_SIZE/2 - 0.2;
  diceBody.position.x = clamp(diceBody.position.x, -safe, safe);
  diceBody.position.z = clamp(diceBody.position.z, -safe, safe);

  diceMesh.position.copy(diceBody.position);
  diceMesh.quaternion.copy(diceBody.quaternion);
  renderer.render(scene, camera);
}
animate();

addEventListener('resize', () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
